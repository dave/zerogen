package main

import (
	"errors"
	"go/ast"
	"io"

	"go/importer"
	"go/types"

	"go/token"

	"strings"

	"reflect"

	"github.com/dave/jennifer/jen"
	"github.com/davecgh/go-spew/spew"
)

const (
	emptyFloat  = "0.0"
	emptyInt    = "0"
	emptyString = ""
)

// generator will work on the selected structure of one file
type generator struct {
	defs       map[*ast.Ident]types.Object
	pkg        *types.Package
	fs         *token.FileSet
	files      []*ast.File
	structures []*ast.TypeSpec
	buf        *jen.File
	pkgName    string
	dirName    string
	inited     bool
	w          io.Writer
}

func newGenerator(str []*ast.TypeSpec, dirname string, files []*ast.File, fs *token.FileSet, pkgName string, w io.Writer) *generator {
	return &generator{
		structures: str,
		pkgName:    pkgName,
		w:          w,
		dirName:    dirname,
		fs:         fs,
		files:      files,
	}
}

func (g *generator) init() error {

	/**
	initializing package parsing with the go/type
	*/

	g.defs = make(map[*ast.Ident]types.Object)
	infos := &types.Info{
		Defs: g.defs,
	}

	config := types.Config{Importer: importer.Default(), FakeImportC: true}

	//var typesPkg *types.Package
	var err error
	g.pkg, err = config.Check(g.dirName, g.fs, g.files, infos)
	if err != nil {
		return err
	}

	_, err = g.w.Write([]byte("// Code generated by github.com/mrsinham/rst. DO NOT EDIT.\n"))
	if err != nil {
		return err
	}
	g.buf = jen.NewFilePathName(g.pkg.Path(), g.pkgName)
	g.inited = true
	return nil
}

func (g *generator) do() error {

	var err error
	if !g.inited {
		err = g.init()
		if err != nil {
			return err
		}
	}
	for i := range g.structures {
		err = g.doOne(g.structures[i])
		if err != nil {
			return err
		}
	}

	return g.buf.Render(g.w)
}

func (g *generator) doOne(t *ast.TypeSpec) error {
	var st *ast.StructType
	var ok bool
	if st, ok = t.Type.(*ast.StructType); !ok {
		// TODO: prevent generator to receive only valid structure
		return errors.New("type spec is not a structtype")
	}

	// write structure func header

	var magicalCode []jen.Code

	// TODO: ensure that st.Fields is not empty
	objectID := string(t.Name.Name[0])
	for i := range st.Fields.List {
		//spew.Dump(st.Fields.List[i])

		// fieds with names
		if len(st.Fields.List[i].Names) == 0 {

			// TODO here lies the inheritance by composition
			continue
		}

		var nonil bool
		// read the current tags
		if st.Fields.List[i].Tag != nil {
			bst := reflect.StructTag(strings.Trim(st.Fields.List[i].Tag.Value, "`"))
			var tc string
			if tc = bst.Get("reset"); tc == "nonil" {
				nonil = true
			}
		}

		if typ := g.defs[st.Fields.List[i].Names[0]]; typ != nil {

			var value *jen.Statement = jen.Id(objectID).Op(".").Id(st.Fields.List[i].Names[0].Name).Op("=")
			switch t := typ.Type().Underlying().(type) {
			case *types.Basic:
				bi := t.Info()
				if bi&types.IsInteger != 0 {
					value.Lit(0)
				}
				if bi&types.IsString != 0 {
					value.Lit("")
				}
			case *types.Array:
				//spew.Config.DisableMethods = true
				if o := strings.LastIndex(t.Elem().String(), "."); o >= 0 {
					value.Index(jen.Lit(int(t.Len()))).Qual(t.Elem().String()[:o], t.Elem().String()[o+1:]).Block()
				} else {
					value.Index(jen.Lit(int(t.Len()))).Id(t.Elem().String()).Block()
				}
			case *types.Map:
				if !nonil {
					value.Nil()
				} else {
					// we dont want the nil value for this type,
					// we want to reinit the value
					var m *jen.Statement
					if o := strings.LastIndex(t.Key().String(), "."); o >= 0 {
						m = jen.Map(jen.Qual(t.Key().String()[:o], t.Key().String()[o+1:]))
						//value.Index(jen.Lit(int(t.Len()))).Qual(t.Elem().String()[:o], t.Elem().String()[o+1:]).Block()
					} else {
						m = jen.Map(jen.Id(t.Key().String()))
					}

					if o := strings.LastIndex(t.Elem().String(), "."); o >= 0 {
						m.Qual(t.Elem().String()[:o], t.Elem().String()[o+1:])
					} else {
						m.Id(t.Elem().String())
					}

					value.Make(m)

				}
			case *types.Pointer:
				if !nonil {
					value.Nil()
				} else {
					var m *jen.Statement
					// removing the pointer reference
					identWithoutpointer := t.String()[1:]
					spew.Dump(identWithoutpointer)
					if o := strings.LastIndex(identWithoutpointer, "."); o >= 0 {
						m = jen.Qual(identWithoutpointer[:o], identWithoutpointer[o+1:])
						//value.Index(jen.Lit(int(t.Len()))).Qual(t.Elem().String()[:o], t.Elem().String()[o+1:]).Block()
					} else {
						m = jen.Id(identWithoutpointer)
					}
					value.Op("&").Add(m).Block()
				}

			case *types.Slice:
				if !nonil {
					value.Nil()
				} else {

				}

			default:
				//spew.Dump(t)
				return errors.New("unsupported type")
			}
			magicalCode = append(magicalCode, value)

		}

		//st.Fields.List[i].
	}

	g.buf.Func().Params(jen.Id(objectID).Op("*").Id(t.Name.Name)).Id("Reset").Params().Block(
		// here generate the code
		magicalCode...,
	)

	//for i := range st.Fields.List {
	//st.Fields.List[i].
	//}

	return nil
}
